#!/usr/bin/env python

""" Dump quality controled CTD data

    Initial prototype. Still needs plenty work.
"""

from optparse import OptionParser

import numpy as np
from numpy import ma

from seabird import CNVError
from cotede.qc import fProfileQC, combined_flag


# ==== Parsing the options on command line
parser = OptionParser()

parser.add_option("--clean", dest="clean",
        action="store_true", default = False,
        help="If selected will remove lines with only bad data.")

parser.add_option("--no-header", dest="noheader",
        action="store_true", default = False,
        help="If selected will not show the header.")

(options, args) = parser.parse_args()


try:
    profile = fProfileQC(args[0], verbose=False)
except CNVError as e:
    print("\033[91m%s\033[0m" % e.msg)
    import sys; sys.exit()
except:
    raise


"Under development. Still need several adjusts to conform with CF-1.5, but it already save usefull data into a netCDF file"

fnameout = args[0].replace(".cnv", "_qced.nc")

import netCDF4

nc = netCDF4.Dataset(fnameout, 'w')

Nz = profile['pressure'].size

nc.createDimension('TIME', 0)
nc.createDimension('DEPTH', Nz)
nc.createDimension('LATITUDE', 1)
nc.createDimension('LONGITUDE', 1)

output = {}
output['TIME'] = nc.createVariable('TIME', 'f8', 'TIME', fill_value=999999.)
output['TIME'].long_name = "time"
output['TIME'].standard_name = "time"
output['TIME'].units = "days since 1950-01-01T00:00:00Z"
output['TIME'].valid_min = 0.
output['TIME'].valid_max = 90000.
output['TIME'].axis = "T"
output['TIME'][0] = netCDF4.date2num(profile.attributes['datetime'],
    "days since 1950-01-01T00:00:00Z")

output['LATITUDE'] = nc.createVariable('LATITUDE', 'f4', 'LATITUDE',
        fill_value=99999.)
output['LATITUDE'].long_name = "Latitude of each location"
output['LATITUDE'].standard_name = "latitude"
output['LATITUDE'].units = "degrees_north"
output['LATITUDE'].valid_min = -90.
output['LATITUDE'].valid_max = 90.
output['LATITUDE'].axis = "Y"

output['LONGITUDE'] = nc.createVariable('LONGITUDE', 'f4', 'LONGITUDE',
        fill_value=99999.)
output['LONGITUDE'].long_name = "Longitude of each location"
output['LONGITUDE'].standard_name = "longitude"
output['LONGITUDE'].units = "degrees_east"
output['LONGITUDE'].valid_min = -180.
output['LONGITUDE'].valid_max = 180.
output['LONGITUDE'].axis = "X"

output['DEPTH'] = nc.createVariable('DEPTH', 'f4', 'DEPTH',
        fill_value=-99999.0)
output['DEPTH'].standard_name = "depth"
output['DEPTH'].units = "meters"
output['DEPTH'].positive = "down"
output['DEPTH'].axis = "Z"
output['DEPTH'].reference = "sea_level"
output['DEPTH'].long_name = "Depth of measurement"
output['DEPTH'].valid_min = 0.
output['DEPTH'].valid_max = 12000.
#DEPTH:QC_indicator = 8 ;
#DEPTH:processing_level ;
#DEPTH:QC_procedure = 2 ;
#DEPTH:uncertainty = 1. ;
output['DEPTH'].ancillary_variables = "DEPH_QC" ;
#DEPTH:comment = "Calculated using integration of insitu density. Sverdrup, et al. 1942" ;
output['DEPTH'].DM_indicator = "D"
output['DEPTH'][:] = profile['pressure']


output['PRES'] = nc.createVariable('PRES', 'f4', 'DEPTH',
        fill_value=-99999.0)
output['PRES'][:] = profile['pressure']


output['TEMP'] = nc.createVariable('TEMP', 'f4', ('TIME','DEPTH'),
        fill_value=99999.)
output['TEMP'].standard_name = "sea_water_temperature"
output['TEMP'].units = "degree_Celsius"
output['TEMP'].long_name = "sea water temperature in-situ ITS-90 scale"
output['TEMP'].valid_min = -2.0
output['TEMP'].valid_max = 40.
output['TEMP'].cell_methods = "TIME: mean DEPTH: point LATITUDE: point LONGITUDE: point"
output['TEMP'].reference_scale = "ITS-90"
output['TEMP'].ancillary_variables = "TEMP_QC"
output['TEMP'][0, :] = profile['temperature']


output['TEMP_QC'] = nc.createVariable('TEMP_QC', 'i1', ('TIME','DEPTH'),
        fill_value=99999.)
output['TEMP_QC'].long_name = "quality flag of sea water temperature"
output['TEMP_QC'].conventions = "OceanSITES QC Flags"
output['TEMP_QC'].coordinates = "TIME DEPTH LATITUDE LONGITUDE"
output['TEMP_QC'].flag_values = [0, 1, 2, 3, 4, 7, 8, 9]
output['TEMP_QC'].flag_meanings = "unknown good_data probably_good_data potentially_correctable bad_data bad_data nominal_value interpolated_value missing_value"
output['TEMP_QC'][0, :] = combined_flag(profile.flags['temperature'])


output['PSAL'] = nc.createVariable('PSAL', 'f4', ('TIME','DEPTH'),
        fill_value=99999.)
output['PSAL'].standard_name = "sea_water_practical_salinity"
output['PSAL'].units = "psu"
output['PSAL'].long_name = "sea water salinity"
output['PSAL'].valid_min = 0.
output['PSAL'].valid_max = 45.
output['PSAL'].cell_methods = "TIME: mean DEPTH: point LATITUDE: point LONGITUDE: point"
output['PSAL'].ancillary_variables = "PSAL_QC"
output['PSAL'][0, :] = profile['salinity']


output['PSAL_QC'] = nc.createVariable('PSAL_QC', 'i1', ('TIME','DEPTH'),
        fill_value=99999.)
output['PSAL_QC'].long_name = "quality flag of sea water salinity"
output['PSAL_QC'].conventions = "OceanSITES QC Flags"
output['PSAL_QC'].coordinates = "TIME DEPTH LATITUDE LONGITUDE"
output['PSAL_QC'].flag_values = [0, 1, 2, 3, 4, 7, 8, 9]
output['PSAL_QC'].flag_meanings = "unknown good_data probably_good_data potentially_correctable bad_data bad_data nominal_value interpolated_value missing_value"
output['PSAL_QC'][0, :] = combined_flag(profile.flags['salinity'])

nc.close()
import sys; sys.exit()

varnames = ['timeS']
output = profile['timeS']

varnames.append('pressure')
output = ma.vstack((output, profile['pressure']))

for v in ['temperature', 'salinity']:
    varnames.append(v)
    output = ma.vstack((output, profile[v]))
    f = combined_flag(profile.flags[v])
    varnames.append("%s_flag" % v)
    output = ma.vstack((output, f))

output = output.T

#import pdb; pdb.set_trace()
header = ""
if options.noheader is False:
    for a in ['filename', 'md5', 'datetime', 'latitude', 'longitude']:
        header += "%s: %s\n" % (a, profile.attributes[a])

#header += "%s\n" % ",\t".join(varnames)
header += ",".join(["%17s" % v for v in varnames])
#np.savetxt('test.out', output, header=header, delimiter=', ')

if options.clean is True:
    output = output[(output[:,5] == 1) & (output[:,3] ==1)]

#print ",\t".join(varnames)
print header
for row in output:
    #print '%10s,\t%10s,\t%8s,\t%i,\t%8s,\t%i' % \
    print '%17s,%17s,%17s,%17s,%17s,%17s' % \
            (row[0], row[1], row[2], int(row[3]), row[4], int(row[5]))

#np.savetxt(args[1], output.T,
#        fmt='%.3f,\t%.2f,\t%.3f,\t%i,\t%.3f,\t%i',
#        header=",\t".join(varnames))
